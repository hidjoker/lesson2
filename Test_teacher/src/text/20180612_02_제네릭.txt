
 + 제네릭, Generics

  - 클래스 또는 메소드에서 사용되는 다양한 데이터타입을
   일반화 시켜 정의하는 방법

  - 코드 재사용성이 높아진다

  - 타입 안정성을 제공한다

  **타입 안정성
	 객체 또는 메소드가 의도하지 않은 타입으로
	사용되는 상황을	방지하는 것

  - 클래스와 메소드에 적용할 수 있다

  - 자주 쓰이는 제네릭 타입명

	T - Type

	E - Element

	K - Key

	V - Value

	N - Number



 + 제네릭 클래스

	[접근제한자] 클래스명<TYPE1, TYPE2, ...> {
		//멤버 정의
	}

  - 객체생성 시 제네릭 타입을 결정해주는 것이 좋다
  - 만약 결정하지 않으면 Object로 사용된다

  - 객체 변수 선언에 제네릭타입을 명시해주고
   객체 생성코드(new)에는 생략하고 <>만 적는다 (JDK1.7 이후)



 + 제네릭 메소드

	[접근제한자] <TYPE1, TYPE2, ...> [리턴타입] [메소드명](..){
		// 구현코드
	}

  - 제네릭 타입 결정하는 방법
	1. 호출 시 메소드명 앞에 직접 명시
		객체.<구체적타입>메소드명(전달인자);

	2. 호출 시 매개변수 타입으로 자동으로 결정되게 하는 방법
		객체.메소드명(전달인자);
		-> 단, 매개변수가 제네릭타입이어야 함

	ex)
		MyClass cls = new MyClass();

		cls.<Integer>method1(); // 방법1

		cls.method2(123); // 방법2



 + 제네릭 제한하기

  - <T extends 부모클래스>

  - T타입은 부모클래스의 하위클래스타입으로만 결정될 수 있다
  - 인터페이스도 마찬가지로 동작함

  ex) <T extends Number>
	-> Byte, Short, Integer, Long, Float, Doulbe 가능



 + 제네릭 클래스(or 인터페이스) 상속하기

  - 부모 타입의 제네릭을 결정하면서 상속한다

  - 결정되지 않은 부모 타입의 제네릭은 자식클래스가
   제네릭타입으로 상속받아야한다

  - 자식타입만의 제네릭 추가 가능



 + 와일드카드

  - 제네릭타입을 정의할 때 구체적인 타입 대신 사용하는 타입

  - 제네릭의 타입을 어떤타입으로든 결정될 수 있도록 허용한다

  - 타입 가변성에 영향을 준다

	<?> : 제한 없는 타입

	<? extends 상위> : '상위'타입의 하위클래스로 결정 가능

	<? super 하위> : '하위'타입의 상위클래스로 결정 가능
